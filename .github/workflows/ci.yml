name: Go CI

# Триггеры для запуска:
# - при пуше в ветку main
# - при создании или обновлении пулл-реквеста на ветку main
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  # Название задачи
  build-and-test:
    # Используем последнюю версию Ubuntu в качестве операционной системы для выполнения задачи
    runs-on: ubuntu-latest

    # Шаги, из которых состоит задача
    steps:
      # Шаг 1: Клонирование репозитория
      # Используем готовый action для получения кода из вашего репозитория
      - name: Checkout repository
        uses: actions/checkout@v4

      # Шаг 2: Установка Go нужной версии
      # Это необходимо для запуска линтеров и тестов
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      # Шаг 3: Кэширование Go-модулей
      # Ускоряет последующие запуски, т.к. зависимости не будут скачиваться заново
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      # Шаг 4: Запуск линтера для проверки качества кода
      # Лучшая практика для поддержания чистоты кода.
      # Указываем working-directory, так как наш go.mod находится в папке 'app'
      - name: Run GolangCI-Lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest
          working-directory: app

      # Шаг 5: Запуск юнит-тестов (если они есть)
      # Этот шаг будет выполнен, даже если у вас пока нет тестов.
      - name: Run Unit Tests
        working-directory: app
        run: go test -v ./...

      # Шаг 6: Сборка и запуск сервисов через Docker Compose
      # Это основная проверка, которая имитирует запуск окружения
      - name: Build and run services with Docker Compose
        run: |
          echo "Building Docker images..."
          docker-compose -f docker/docker-compose.development.yml build
          
          echo "Starting services in detached mode..."
          docker-compose -f docker/docker-compose.development.yml up -d

      # Шаг 7: Проверка работоспособности приложения
      # Даем контейнерам немного времени на запуск и проверяем, отвечает ли сервер.
      - name: Verify Application is Running
        run: |
          echo "Waiting for services to start..."
          sleep 15
          
          echo "Checking application health via curl..."
          # Пробуем подключиться к порту 8080. Делаем 5 попыток с интервалом в 2 секунды.
          curl --retry 5 --retry-delay 2 -v http://localhost:8080
          
          echo "Displaying container logs for debugging..."
          docker-compose -f docker/docker-compose.development.yml logs go

      # Шаг 8: Очистка
      # Останавливаем и удаляем контейнеры в любом случае (даже если предыдущие шаги провалились)
      - name: Stop and remove containers
        if: always()
        run: docker-compose -f docker/docker-compose.development.yml down